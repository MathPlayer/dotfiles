#
# ~/.shellrc
#
# File with environment definitions.
#

# Source user's comnands file for helper functions.
if [ -f "${HOME}/.bin/commands.sh" ]; then
  . "${HOME}/.bin/commands.sh"
fi

################################################################################
# Alter the path variables: PATH, PYTHONPATH.
# This is doing with the following steps:
# 1. Create a USER_<PATH> variable.
# 2. Add to USER_<PATH> the paths to be considered before the standard ones.
# 3. Prepend <PATH> with USER_<PATH>.
# This way, the paths configured below are listed in their order of importance.

USER_PATH=""

# Adds $1 to $USER_PATH if $1 is a directory.
add_user_path() {
  if [ -d "$1" ]; then
    if [ -z "${USER_PATH}" ]; then
      USER_PATH="$1"
    else
      USER_PATH="${USER_PATH}:$1"
    fi
  fi
  return 0
}

# User's private bin.
add_user_path "${HOME}/.bin"

# Find brew.
if command_exists "brew"; then
  BREW_CMD="brew"
elif [ -f "${HOME}/homebrew/bin/brew" ]; then
  BREW_CMD="${HOME}/homebrew/bin/brew"
else
  BREW_CMD=
fi

if [ ! -z "${BREW_CMD}" ]; then
  HOMEBREW_DIR="$(${BREW_CMD} --prefix)"
else
  HOMEBREW_DIR=
fi

# Paths for Homebrew.
if [ ! -z "${HOMEBREW_DIR}" ]; then
  # TODO: /usr/local/bin is already in $PATH. If brew is installed in the default path, this adds a
  # duplicate.
  add_user_path "${HOMEBREW_DIR}/bin"
  add_user_path "${HOMEBREW_DIR}/sbin"
  add_user_path "${HOMEBREW_DIR}/opt/python/libexec/bin"
  add_user_path "${HOMEBREW_DIR}/opt/curl/bin"
  add_user_path "${HOMEBREW_DIR}/opt/sqlite/bin"
  add_user_path "${HOMEBREW_DIR}/opt/llvm/bin"
fi

unset HOMEBREW_DIR

# Jenv
if command_exists "jenv"; then
  eval "$(jenv init - --no-rehash)"
  (jenv rehash &) 2> /dev/null
  add_user_path "${HOME}/.jenv/bin"
fi

# Rbenv
if command_exists "rbenv"; then
  eval "$(rbenv init - --no-rehash)"
  (rbenv rehash &) 2> /dev/null
fi

# Pyenv
if command_exists "pyenv"; then
  eval "$(pyenv init - --no-rehash)"
  (pyenv rehash &) 2> /dev/null
  if command_exists "pyenv-virtualenv-init"; then
    eval "$(pyenv virtualenv-init -)"
    # avoid double virtualenv name mention in prompt, see pyenv-virtualenv info message below:
    # pyenv-virtualenv: prompt changing will be removed from future release.
    # configure `export PYENV_VIRTUALENV_DISABLE_PROMPT=1' to simulate the behavior.
    export PYENV_VIRTUALENV_DISABLE_PROMPT=1
  fi
fi

# User-installed ruby paths.
add_user_path "${HOME}/.gem/ruby/2.3.0/bin"

# Rustup path
add_user_path "${HOME}/.cargo/bin"

# Merge the user paths configured above into the environment.
# TODO: filter existing paths in $PATH, add only new ones.
if [ -n "${USER_PATH}" ]; then
  export PATH="${USER_PATH}:${PATH}"
fi

# Cleanup.
unset USER_PATH

################################################################################
# Various others.

# Set language defaults.
export LC_ALL="en_US.UTF-8"
export LANG="en_US.UTF-8"
export LC_CTYPE="en_US.UTF-8"

# Set default settings for LESS.
export LESS="-RFX"

# Set text editor.
command_exists "vim" && export EDITOR="vim"
command_exists "nvim" && export EDITOR="nvim"

# Set make flags with a default cpu count.
command_exists nproc && export MAKEFLAGS="-j $(nproc)"

# Set umask.
umask 027

# Accept custom, work-related configuration.
MY_WORK_DIR="${HOME}/work"
if [ -d "${MY_WORK_DIR}" ]; then
  export MY_WORK_DIR="${MY_WORK_DIR}"
  source_if_exists "${MY_WORK_DIR}/.shellrc"
fi
unset MY_WORK_DIR
